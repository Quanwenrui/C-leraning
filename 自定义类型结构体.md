# 自定义类型:结构体

## 1.结构体类型的声明

**C语言中有==内置类型==(char,short,int,long,double... ...),这些是C语言本身支持的类型,仅仅有内置类型是不够的.C允许自定义类型eg:结构体,枚举,... ...**

**结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。**

### 结构体类型创建

<img src="C:\Users\12267\AppData\Roaming\Typora\typora-user-images\image-20250331134316451.png" alt="image-20250331134316451" style="zoom: 50%;" />

### **创建结构体变量并进行初始化**

```c
#include<stdio.h>
struct book
{
	char name[20];
	int age;
	char id[20];
}s3,s4;//全局变量
	struct book s2;//全局变量
int main()
{
	struct book s1;//局部变量
	struct book s5 = {"鹿野千夏",17,"xiaorizi"};//创建全局变量//初始化/按顺序初始化的写法
	//struct book s5 = {.age = 17,.name="鹿野千夏",.id="xiaorizi"};//乱序初始化
	struct book arr[5];//用来创建数组,有5个这样的元素
	return 0;
}
```

### **结构体的特殊声明**

在声明结构的时候，可以不完全的声明,可以出现匿名结构体

```c
//匿名结构体类型
struct		//只用一次的情况才考虑使用匿名结构体
{
 int a;
 char b;
 float c;
 }x={3,'s',3.4f};//匿名结构体只能在这用一次,没有类型名,没有后续的使用了,变量x可以使用
struct
{
 int a;
 char b;
 float c;
}a[20], *p;
```

- **只用一次的情况**才考虑使用**匿名结构体**

### 结构的自引用

- 链表节点的定义(链表包含两个信息,数据域和指针域)

```c
struct Node
{
 int data;
 struct Node next;
};
```

**这样写代码不合理:**

仔细分析，其实是不行的，因为一个结构体中再包含一个同类型的结构体变量，这样结构体变量的大小就会无穷的大，是不合理的。

正确自引用方式:

```c
struct Node
{
	int data;
 	struct Node* next;//存放下一个节点地址-->指针(域).
};
```

**常见的结构体写法:**

```c
typedef struct Node//类型的重命名
{
	int data;//数据
 	struct Node* next;//指针
}Node;
//前四行等价于://typedef struct Node Node;
int main()
{
	Node n;
	return 0;
}
```

**要注意的是:匿名的结构体类型是不能实现这种结构体的自引用效果的**

## 2.结构体内存对齐

``引子``

**计算结构体的大小:结构体内存对齐**

```c
struct S
{
	char b;//占1个字节
    int a;//占4个字节
	chart c;//占1个字节
};
int main()
{
	struct S s = {0};//创建变量,不知道放什么可以放0
	printf("%zd\n",sizeof(s)); 
    //这个小s是结构体变量,打印结果是12.//占12个字节
    //sizeof返回的是size_t类型的值,用%zd打印
    //%zd打印的是无符号整型
	return 0;
}
```

### **对齐规则(4条): **

![image-20250401142127608](自定义类型结构体.assets/image-20250401142127608.png)

***结构体的对齐规则:***

> - **(一)结构体的==第一个成员==对齐到和结构体变量==起始位置偏移量为0==的地址处**
>
>   **(偏移量:创建变量s,一定会在内存中找一块空间存放,第一个元素==从偏移量为0的地方开始存放==,存的第一个字节相对起始位置的偏移量就是0,以此类推)**
>
> - **(二)其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。**
>
> **==对齐数== = 编译器默认的一个对齐数与该成员变量大小的==较小值==。**
>
> **(拿第二个存的为int举例,int类型4个字节,而VS给的默认对齐数是8,4是里面的较小值,就说对齐数是4,放第2个元素就要==在第1后边且是对齐数(4)的倍数的地址处(4/8/12/... ...)开始存==对应成员变量)**
>
> --VS中默认的值位8
>
> --linux中gcc没有默认对齐数,对齐数就是成员自身大小
>
> - **(三)结构体总大小为==最大对齐数的整数倍.==(会向后占用,因而浪费空间)**
>
>   ​	**最大对齐数(结构体中每个成员变量都有⼀个对数，==所有对齐数中最大的==)**
>
> - **(四)如果嵌套了结构体的情况，嵌套的结构体成员对齐到自己的成员中最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体中成员的对齐数）的整数倍。**



```c
//练习1
struct S1
{
 char c1;
 int i;
 char c2;
};
int main()
{
	struct S1 S1 = { 0 };
	printf("%d\n", sizeof(struct S1));//12
	return 0;
}
```

<img src="自定义类型结构体.assets/image-20250401143637836.png" alt="image-20250401143637836" style="zoom: 33%;" />

```c
//练习2
struct S2
{
 char c1;
 char c2;
 int i;
};
printf("%d\n", sizeof(struct s2));//8
```

<img src="自定义类型结构体.assets/image-20250401143657477.png" alt="image-20250401143657477" style="zoom: 33%;" />

```c
//练习3
struct S3
{
 double d;
 char c;
 //char m[5];//放数组的话就当成放了5个char即可//****数组的计算方式//数组本身在内存中就是连续存放的
 int i;
};
printf("%d\n", sizeof(struct S3));//16
```

<img src="自定义类型结构体.assets/image-20250401143717720.png" alt="image-20250401143717720" style="zoom: 33%;" />

```c
//练习4-结构体嵌套结构体的问题
struct S3
{
 double d;
 char c;
 int i;
};
struct S4
{
 char c1;
 struct S3 s3;
 double d;
};
printf("%d\n", sizeof(struct S4));//32//最大对齐数:8
```

### 存在内存对齐的原因:

大部分的参考资料都是这样说的：

1.平台原因 (移植原因):

不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据,否则抛出硬件异常.

2.性能原因:

数据结构(尤其是栈)应该尽可能地在自然边界上对齐.原因在于,为了访问未对齐的内存,处理器需要作两次内存访问；而对齐的内存访问仅需要⼀次访问.假设一个处理器总是从内存中取8个字节,则地址必须是8的倍数.如果我们能保证将所有的double类型的数据的地址都对齐成8的倍数,那么就可以用一个内存操作来读或者写值了.否则,我们可能需要执行两次内存访问,因为对象可能被分放在两个8字节内存块中

**总体来说：**结构体的内存对齐是拿**空间**来换取**时间**的做法。
